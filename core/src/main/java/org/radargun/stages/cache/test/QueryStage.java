package org.radargun.stages.cache.test;

import org.radargun.DistStageAck;
import org.radargun.Operation;
import org.radargun.StageResult;
import org.radargun.config.Property;
import org.radargun.config.Stage;
import org.radargun.reporting.Report;
import org.radargun.stages.test.OperationLogic;
import org.radargun.stages.test.Stressor;
import org.radargun.state.SlaveState;
import org.radargun.stats.Statistics;
import org.radargun.traits.InjectTrait;
import org.radargun.traits.Query;
import org.radargun.traits.InternalsExposition;
import org.radargun.traits.Queryable;
import org.radargun.utils.MinMax;
import org.radargun.utils.Projections;

import java.text.DecimalFormat;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Executes Queries using Infinispan-Query API against the cache.
 *
 * @author Anna Manukyan
 */
@Stage(doc = "Stage which executes a Query using Infinispan-query API against all keys in the cache.")
public class QueryStage extends AbstractQueryStage {

   @Property(doc = "Number of queries generated by each thread. Makes sense only when random values are used. By default 1.")
   private int numQueries = 1;

   @Property(doc = "Check whether all invocations got the same result, and fail if not. Default is false.")
   private boolean checkSameResult = false;

   @Property(doc = "Check whether a query performed by a thread multiple times returns the same value. Default is true.")
   private boolean checkSameThreadResult = true;

   @InjectTrait(dependency = InjectTrait.Dependency.MANDATORY)
   private Queryable queryable;

   @InjectTrait
   private InternalsExposition internalsExposition;

   protected AtomicInteger minResultSize = new AtomicInteger(-1);
   protected AtomicInteger maxResultSize = new AtomicInteger(-1);

   @Override
   public OperationLogic getLogic() {
      return new Logic();
   }

   @Override
   protected DistStageAck newStatisticsAck(List<Stressor> stressors) {
      long cacheHits = 0, cacheMisses = 0, cacheEntries = 0;
      if (internalsExposition != null) {
         String prefix = "query-cache:";
         cacheHits = parse(internalsExposition.getCustomStatistics(prefix + "hits"));
         cacheMisses = parse(internalsExposition.getCustomStatistics(prefix + "misses"));
         cacheEntries = parse(internalsExposition.getCustomStatistics(prefix + "numberOfEntries"));
      }
      log.infof("Min %d, max %d", minResultSize.get(), maxResultSize.get());
      double hitPercentage = (cacheHits + cacheMisses == 0 ? 0 : (double) cacheHits / (double) (cacheHits + cacheMisses));
      return new QueryAck(slaveState, gatherResults(stressors, new StatisticsResultRetriever()),
            minResultSize.get(), maxResultSize.get(), hitPercentage, cacheEntries);
   }

   private long parse(String str) {
      if (str == null) return 0;
      return Long.parseLong(str);
   }

   @Override
   public StageResult processAckOnMaster(List<DistStageAck> acks) {
      StageResult result = super.processAckOnMaster(acks);
      if (result.isError()) return result;

      MinMax.Int resultSize = new MinMax.Int();
      MinMax.Double hitPercentage = new MinMax.Double();
      MinMax.Long cacheEntries = new MinMax.Long();
      Map<Integer, Report.SlaveResult> slaveResultSizes = new HashMap<>();
      Map<Integer, Report.SlaveResult> slaveHitRatios = new HashMap<>();
      Map<Integer, Report.SlaveResult> slaveCacheEntries = new HashMap<>();
      for (QueryAck ack : Projections.instancesOf(acks, QueryAck.class)) {
         if (resultSize.isSet() && (resultSize.min() != ack.minResultSize || resultSize.max() != ack.maxResultSize)) {
            String message = String.format("The size got from %d -> %d .. %d is not the same as from other slaves -> %d .. %d ",
                  ack.getSlaveIndex(), ack.minResultSize, ack.maxResultSize, resultSize.min(), resultSize.max());
            if (checkSameResult) {
               log.error(message);
               return errorResult();
            } else {
               log.info(message);
            }
         }
         resultSize.add(ack.minResultSize).add(ack.maxResultSize);
         slaveResultSizes.put(ack.getSlaveIndex(), new Report.SlaveResult(MinMax.Int.toString(ack.minResultSize, ack.maxResultSize), false));
         hitPercentage.add(ack.hitPercentage);
         slaveHitRatios.put(ack.getSlaveIndex(), new Report.SlaveResult(String.valueOf(ack.hitPercentage), false));
         cacheEntries.add(ack.cacheEntries);
         slaveCacheEntries.put(ack.getSlaveIndex(), new Report.SlaveResult(String.valueOf(ack.cacheEntries), false));
      }
      Report.Test test = getTest(true); // the test was already created in super.processAckOnMaster
      if (test != null) {
         test.addResult(getTestIteration(), new Report.TestResult("Query result size", slaveResultSizes, resultSize.toString(), false));
         test.addResult(getTestIteration(), new Report.TestResult("Cache hit percentage", slaveHitRatios, hitPercentage.toString(new DecimalFormat("##.#%")), false));
         test.addResult(getTestIteration(), new Report.TestResult("Cache size", slaveCacheEntries, cacheEntries.toString(), false));
      } else {
         log.info("No test name - results are not recorded");
      }
      return result;
   }

   protected static class QueryAck extends StatisticsAck {
      public final int minResultSize;
      public final int maxResultSize;
      public final double hitPercentage;
      public final long cacheEntries;

      public QueryAck(SlaveState slaveState, List<List<Statistics>> iterations, int minResultSize, int maxResultSize, double hitPercentage, long cacheEntries) {
         super(slaveState, iterations);
         this.minResultSize = minResultSize;
         this.maxResultSize = maxResultSize;
         this.hitPercentage = hitPercentage;
         this.cacheEntries = cacheEntries;
      }
   }

   protected class Logic extends OperationLogic {
      protected Query.Builder[] builders;
      protected Query.Result previousQueryResult = null;

      @Override
      public void init(Stressor stressor) {
         super.init(stressor);
         Class<?> clazz;
         try {
            clazz = Class.forName(queryObjectClass);
         } catch (ClassNotFoundException e) {
            throw new IllegalArgumentException("Cannot load class " + queryObjectClass, e);
         }
         builders = new Query.Builder[numQueries];
         for (int i = 0; i < numQueries; ++i) {
            Query.Builder builder = queryable.getBuilder(null, clazz);
            for (Condition condition : conditions) {
               condition.apply(builder);
            }
            if (orderBy != null) {
               for (SortElement se : orderBy) {
                  builder.orderBy(se.attribute, se.asc ? Query.SortOrder.ASCENDING : Query.SortOrder.DESCENDING);
               }
            }
            if (projection != null) {
               builder.projection(projection);
            }
            if (offset >= 0) {
               builder.offset(offset);
            }
            if (limit >= 0) {
               builder.limit(limit);
            }
            builders[i] = builder;
         }
      }

      @Override
      public void run(Operation ignored) throws RequestException {
         Query query = builders[stressor.getRandom().nextInt(numQueries)].build();
         Query.Result queryResult;
         try (Query.Context context = queryable.createContext(null)) {
            queryResult = (Query.Result) stressor.makeRequest(new Invocations.Query(query, context));
         }

         if (!checkSameThreadResult) {
            return;
         }
         int size = queryResult.size();
         if (previousQueryResult != null) {
            if (size != previousQueryResult.size()) {
               throw new IllegalStateException("The query result is different from the previous one. All results should be the same when executing the same query");
            }
         } else {
            log.info("First result has " + size + " entries");
            if (log.isTraceEnabled()) {
               for (Object entry : queryResult.values()) {
                  log.trace(String.valueOf(entry));
               }
            }
            int min = minResultSize.get();
            if (checkSameResult && min >= 0 && min != size) {
               throw new IllegalStateException("Another thread reported " + min + " results while we have " + size);
            }
            while ((min < 0 || min > size) && !minResultSize.compareAndSet(min, size)) {
               min = minResultSize.get();
            }
            int max = minResultSize.get();
            if (checkSameResult && max >= 0 && max != size) {
               throw new IllegalStateException("Another thread reported " + max + " results while we have " + size);
            }
            while ((max < 0 || max < size) && !maxResultSize.compareAndSet(max, size)) {
               max = maxResultSize.get();
            }
         }
         previousQueryResult = queryResult;
      }
   }
}
